Traceback (most recent call last):
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/nbclient/client.py", line 1305, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/jupyter_core/utils/__init__.py", line 173, in wrapped
    return loop.run_until_complete(inner)
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/asyncio/base_events.py", line 616, in run_until_complete
    return future.result()
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/nbclient/client.py", line 705, in async_execute
    await self.async_execute_cell(
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/nbclient/client.py", line 1058, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/nbclient/client.py", line 914, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
""" Schmitt Trigger interactive plot
"""
%matplotlib widget
from ipywidgets.widgets import IntSlider, FloatSlider, Textarea
from ipywidgets import interact
from math import ceil, exp
from matplotlib.lines import Line2D
from matplotlib.pyplot import figure
from numpy import float64, linspace, pi, sign, sin, array, greater
from numpy.typing import NDArray
from scipy import signal
from scipy.signal import argrelextrema
from typing import Sequence

def ThresholdCalculator(Vdd:float, R1: int, R2: int, Rf: int)-> tuple[float, float]:
    """ Calculates the threshold voltage on a Schmitt trigger (single rail,
    biased with a voltage divider, ideal rail to rail opamp)
    Parameters:
    -----------
        VoutH: float
            The value of VoutH when the opamp is saturated high
        VoutL: float
            The value of VoutH when the opamp is saturated low
        Vdd: floag
            the power supply voltage
        R1: int
            top resistor of the voltage divider
        R2: int
            bottom resistor of the voltage divider
        Rf: int
            feedback resistor
    Return
    ------
        VthL: float
            the threshold value when the output is LOW
        VthH: float
            the thershokd value when the output is HIGH
    """
    parallelR1Rf:float= (R1 * Rf) / (R1 + Rf)
    parallelR2Rf:float= (R2 * Rf) / (R2 + Rf)
    ratioH:float = (parallelR1Rf / R2) + 1
    ratioL:float = (R1 / parallelR2Rf) + 1
    VthH:float = Vdd / ratioH
    VthL:float = Vdd / ratioL
    return VthL, VthH

def ThresholdSignal(Vout: Line2D, VthL: float, VthH:float, Vdd: float)-> Sequence[float]:
    """ Calculates the threshold voltage signanl on a Schmitt trigger (single rail,
    biased with a voltage divider)
    Parameters:
    -----------
        Vout: float
            a line 2D with the values of the output signal of the opAmp, as
            they determine the threshold value
        VthL: float
            the threshold value when the output is LOW
        VthH: float
            the thershokd value when the output is HIGH
        Vdd: int
            the power supply voltage
    Return
    ------
        returnArray: Sequence[float]
            a sequence with the values of the Schmitt Trigger thresholds, depending
            on the values of the resistor network, Vdd and the current output of
            the OpAmp
    """
    returnArray:Sequence[float] = []
    # extrac data from Vout (line2D) to array
    voltages:Sequence[float] = Vout.get_ydata()
    for i in range(len(voltages)):
        if voltages[i] > (Vdd / 2):
            returnArray.append(VthH)
        else:
            returnArray.append(VthL)
    return returnArray

def capacitor_voltage(t:float, R: int, C: float, Vapplied:float)->float:
    """ Calculates the voltage of a capacitor (Vout) in an RC filter after
    time = t seconds, when Vapplied volts are applied at the input
    Parameters:
    -----------
        t: float
            time elapsed in seconds since Vapplied was applied at the input of
            the RC filter
        R: int
            The value of the resistor (in Î©) of the RC filter
        C: float
            The value of the capacitor (in Farads) of the RC filter
        Vapplied: float
            The voltage (in Volts) applied at the input
    Retunr
    --------
        cap_Volt: float
            The voltage in the capacitor in Volts (Vout of the RC filter)
    """
    cap_volt = Vapplied * (1 - exp (-t/(R*C)))
    return cap_volt

def astable_vibrator_signals(times:NDArray[float64], Rd1:int, Rd2:int, Rf:int, Rc:int, C:float, Vdd:float)->tuple[Sequence[float], Sequence[float], Sequence[float]]:
    """ Calculates the values of the signals of interest on an Astable Multivibrator: the
    voltages at the inverting and non inverting pins and the output signal. The amplifier
    is ideal, powered with a single rail and biased with a voltage divider.
    The calculations are based on the values of the feedback resistor Rf, the values of the
    resistors on the voltage divider and the values of the RC filter in the non-inverting pin
    as well as the Vdd voltage.
    Parameters:
    -----------
        times: NDArray[float64]
            A sequence of values for the time at wich the values of the signals has to be calculated
        Rd1:int
            The value of the voltage divider resistor connected to VDD
        Rd2:int
            The value of the voltage divider resistor connected to GND
        Rf:int
            The value of the feedback resistor connected from out to v+.
        Rc: int
            The value of the resistor (in Î©) connected to the RC filter
        C: float
            The value of the capacitor (in Farads) in the RC filter
        Vdd: float
            the voltage applied to the capacitor. It's constant for all the values in times
    Return
    ------
        [vi_signal, vo_signal, vf_signal]: tuple[Sequence[float],Sequence[float],Sequence[float]
            Sequences with the values of voltage at the inverting, output and non-inverting
            pins of the OpAmp, respectively.
    """
    vi_signal:Sequence[float] = [0.0] * len(times)
    vo_signal:Sequence[float] = [0.0] * len(times)
    vf_signal:Sequence[float] = [0.0] * len(times)

    # Get the schimtt trigger thresholds for this config
    thresholdl, thresholdh = ThresholdCalculator(Vdd, Rd1, Rd2, Rf)

    #initial conditions
    vi_signal[0] = 0 # capacitor starts discharged
    # vi below threshold, so vo is HIGH
    vo_signal[0] = Vdd
    # vo is HIGH so Vthreshold is VthH
    vf_signal[0] = thresholdh
    start_t = times[0]
    start_v = 0
    rising = False # an aux variable to keep track if we are charging or discharging C
    if vi_signal[0] < vf_signal[0]:
        rising = True

    for i in range(1, len(times)): #skip times[0] as we have entered the initial conditions by hand
        if vi_signal[i - 1] < vf_signal[i-1]:
            # If v- < v+, the voltage at the cap is below trheshold
            # We will charge the capacitor
            time = times[i]
            vi_signal[i] = capacitor_voltage(time-start_t, Rc, C, Vdd - start_v) + start_v
            vf_signal[i] = thresholdh
            vo_signal[i] = Vdd
        else: # vi_signal[i - 1] >= vf_signal[i-1]:
            # Else, the voltage at the cap is above the trheshold
            # We will discharge the capacitor
            time = times[i]
            vi_signal[i] = capacitor_voltage(time-start_t, Rc, C, 0 - start_v) + start_v
            vf_signal[i] = thresholdl
            vo_signal[i] = 0
        # after updating the values, check if we switched the thresholds
        if (vi_signal[i] >= vf_signal[i]) and rising:
            start_v = thresholdh
            start_t = times[i]
            rising = False
        elif (vi_signal[i] <= vf_signal[i]) and not rising:
            start_v = thresholdl
            start_t = times[i]
            rising = True
    return vi_signal, vo_signal, vf_signal

# Resistor Values and VDD
R_1 = 10000
R_2 = 10000
R_3 = 10000
Vdd = 3
# x axis is 0 to 4s, 100 values
x = linspace(0, 4, 100)
fig = figure()
ax = fig.add_subplot(1, 1, 1)
# Generate a square signal, simulating the switching output of the opamp, .5Hz
out_signal, = ax.plot(x, 3/2 * (signal.square(2 * pi * 1/2 * x) + 1))
# Calculate the threshold values for the resistor network and the output signal
thresholdl, thresholdh = ThresholdCalculator(Vdd, R_1, R_2, R_3)
threshold_signal, = ax.plot(x, ThresholdSignal(out_signal, thresholdl, thresholdh, Vdd))

def update(R1:int=1, R2:int=1, R3:int=1):
    thresholdl, thresholdh = ThresholdCalculator(Vdd, R1, R2, R3)
    print(f"Threshold low is {thresholdl:.2f}V and threshold high is {thresholdh:.2f}V. Ratio is {100 * (thresholdh - thresholdl) / Vdd:.0f}% of VDD")
    threshold_signal.set_ydata(ThresholdSignal(out_signal, thresholdl, thresholdh, Vdd))
    fig.canvas.draw_idle()

# Create a wiget for
R1 = IntSlider(value=10000, min=1000, max=50000, step=1000, description='R1 (Î©):',
    orientation='horizontal', readout=True, readout_format='.2d')
R2 = IntSlider(value=10000, min=1000, max=50000, step=1000, description='R2 (Î©):',
    orientation='horizontal', readout=True, readout_format='.2d')
Rf = IntSlider(value=10000, min=1000, max=50000, step=1000, description='Rf (Î©):',
    orientation='horizontal', readout=True, readout_format='.2d')
thresholdL = Textarea(
    value='"0"',
    placeholder='"0"',
    description='String:',
)
interact(update, R1=R1, R2=R2, R3=Rf);
------------------


[0;31m---------------------------------------------------------------------------[0m
[0;31mTypeError[0m                                 Traceback (most recent call last)
Cell [0;32mIn[1], line 15[0m
[1;32m     12[0m [38;5;28;01mfrom[39;00m [38;5;21;01mscipy[39;00m[38;5;21;01m.[39;00m[38;5;21;01msignal[39;00m [38;5;28;01mimport[39;00m argrelextrema
[1;32m     13[0m [38;5;28;01mfrom[39;00m [38;5;21;01mtyping[39;00m [38;5;28;01mimport[39;00m Sequence
[0;32m---> 15[0m [38;5;28;01mdef[39;00m [38;5;21mThresholdCalculator[39m(Vdd:[38;5;28mfloat[39m, R1: [38;5;28mint[39m, R2: [38;5;28mint[39m, Rf: [38;5;28mint[39m)[38;5;241m-[39m[38;5;241m>[39m [38;5;28;43mtuple[39;49m[43m[[49m[38;5;28;43mfloat[39;49m[43m,[49m[43m [49m[38;5;28;43mfloat[39;49m[43m][49m:
[1;32m     16[0m [38;5;250m    [39m[38;5;124;03m""" Calculates the threshold voltage on a Schmitt trigger (single rail,[39;00m
[1;32m     17[0m [38;5;124;03m    biased with a voltage divider, ideal rail to rail opamp)[39;00m
[1;32m     18[0m [38;5;124;03m    Parameters:[39;00m
[0;32m   (...)[0m
[1;32m     37[0m [38;5;124;03m            the thershokd value when the output is HIGH[39;00m
[1;32m     38[0m [38;5;124;03m    """[39;00m
[1;32m     39[0m     parallelR1Rf:[38;5;28mfloat[39m[38;5;241m=[39m (R1 [38;5;241m*[39m Rf) [38;5;241m/[39m (R1 [38;5;241m+[39m Rf)

[0;31mTypeError[0m: 'type' object is not subscriptable

